{% extends 'base.html' %}
{% load static %}
{% block body %}


<div class="jumbotron jumbotron-fluid"
    style="background-image: url({% static 'img/jumbo.png' %}); background-size: cover;">
    <div class=" container">
        <h1 class="display-4 pt-5" style="text-align: center;">Process Scheduling</h1>
    </div>
</div>

  <!-- About Section -->
    <div class="container">

            <h2 class="w3-center" style="text-align: center;"><strong>About Process Scheduling</strong></h1><br>
            <p class="w3-large"><b>Process Scheduling</b> is the activity in which the Process Manager handles the selection and removal (i.e scheduling) of processes to be run on the basis of a particular strategy.<br>
                                Process scheduling is an essential part of a Multiprogramming operating system. Such operating systems allow more than one process to be loaded into the executable memory at one time and the loaded process shares the CPU using time multiplexing.</p>
            <p class="w3-large w3-text-grey w3-hide-medium">A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms.<br>We are going to discuss 8 popular process scheduling algorithms:<br><br>
                                                            1.First-Come, First-Served (FCFS) Scheduling<br>
                                                            2.Shortest Job Next (SJN) Scheduling<br>
                                                            3.Priority Scheduling<br>
                                                            4.Shortest Remaining Time First Scheduling<br>
                                                            5.Longest Job Next Scheduling<br>
                                                            6.Longest Remaining Time First Scheduling<br>
                                                            7.Round Robin (RR) Scheduling<br>
                                                            8.Highest Response Ratio Next Scheduling<br></p>
            <p class="w3-large">These algorithms are either Non-Preemptive or Preemptive. Non-preemptive algorithms are designed so that once a process enters the running state, it cannot be preempted or removed until it completes its allotted time or function, whereas preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state.</p>
    </div>
    <br>

  <!-- Menu Section -->
    <div class="container">
        <div class="w3-col l6 w3-padding-large">
            <h2 class="w3-center" style="text-align: center;"><strong>Types</strong></h2><br>
            <h4>First Come First Serve (FCFS) Scheduling</h4>
            <p class="w3-text-grey">In the First Come First Serve scheduling algorithm, as the name suggests, the process which arrives first, gets executed first, or we can say that the process which requests the CPU first, gets the CPU allocated first. The implementation is based on FIFO queue. However it is poor in terms of performance as average wait time is high and hence overall efficiency is affected</p><br>

            <h4>Shortest Job Next (SJN) Scheduling</h4>
            <p class="w3-text-grey">This is also known as Shortest Job First, or SJF. It can be a non-preemptive or preemptive scheduling algorithm. It is the best approach to minimize waiting time.
                                    It is quite easy to implement in batch systems where required CPU time is known in advance but it is impossible to implement in interactive systems where required CPU time is not known as the processor should know in advance how much time process will take.</p><br>

            <h4>Priority Based Scheduling</h4>
            <p class="w3-text-grey">Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems. Each process is assigned a priority. Process with highest priority is to be executed first and so on.
                                    Processes with same priority are executed on first come first served basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement.<br>
                                    In priority-based scheduling algorithms, a major problem is indefinite block, or starvation. A process that is ready to run but waiting for the CPU can be considered blocked. A priority scheduling algorithm can leave some low-priority processes waiting indefinitely.
                                    A steady stream of higher-priority processes can prevent a low-priority process from ever getting the CPU.<br>
                                    Aging is used to ensure that jobs with lower priority will eventually complete their execution. This technique can be used to reduce starvation of low priority tasks. There are many ways to implement aging, but all have the same principle that the priority of a process should increase as it waits in the ready queue.
                                    The increase in priority may or may not be equal to the waiting time of the process.</p><br>

            <h4>Shortest Remaining Time First (SRTF)</h4>
            <p class="w3-text-grey">Shortest remaining time (SRTF) is the preemptive version of the SJN algorithm. The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion.
                                    Once again it is impossible to implement in interactive systems where required CPU time is not known. It is often used in batch environments where short jobs need to give preference.</p><br>

            <h4>Longest Job Next (LJN)</h4>
            <p class="w3-text-grey">This algorithm is very similar to SJN, but gives priority to processes with longer burst times instead of shorter ones. It can be a non-preemptive or preemptive scheduling algorithm. It is quite easy to understand and implement; implementation is based on FIFO queue. However, LJF is not considered to be an efficient way of process scheduling because there are many drawbacks to it, like the Convoy effect is displayed by it. It has very large average turn-around time and average waiting times. This results in slow processing and decreases the efficiency of the system.</p><br>

            <h4>Longest Remaining Time First (LRTF)</h4>
            <p class="w3-text-grey">Longest remaining Time First (LRTF) is the preemptive version of the LJN algorithm. The processor is allocated to the longest job available in terms of burst time, but it can be preempted by a newer ready job with longer burst time. Similar to LJN, LRTF is not considered to be an efficient way of process scheduling because there are many drawbacks to it like the Convoy effect displayed by it, it also has very large average turn-around time and average waiting times, and hence results in slow processing and decreases the effectiveness of the system.</p><br>

            <h4>Round Robin Scheduling (RR)</h4>
            <p class="w3-text-grey">Round Robin scheduling algorithm is one of the most popular scheduling algorithm which can actually be implemented in most of the operating systems. It can be considered as the preemptive version of first come first serve scheduling. The Algorithm focuses on Time Sharing. In this algorithm, every process gets executed in a cyclic way. A certain time slice is defined in the system which is called time quantum. Each process present in the ready queue is assigned the CPU for that time quantum, if the execution of the process is completed during that time then the process will terminate else the process will go back to the ready queue and waits for the next turn to resume the execution.</p><br>

            <h4>Highest Response Ratio Next (HRRN) Scheduling</h4>
            <p class="w3-text-grey">Highest Response Ratio Next (HRRN) is one of the most optimal scheduling algorithms. This is a non-preemptive algorithm in which, the scheduling is done on the basis of an extra parameter called Response Ratio. A Response Ratio is calculated for each of the available jobs and the Job with the highest response ratio is given priority over the others.
			Response Ratio is calculated by the given formula.

    			Response Ratio = (W+S)/S   

			Where,

 		    W → Waiting Time   
    		S → Service Time or Burst Time  

			We notice that the job with the shorter burst time will be given priority but it is also including an extra factor, waiting time. It is non preemptive hence context switching is minimal in this algorithm.
</p><br><br><br>

        </div>
    </div>
    <hr>

<!-- End page content -->
    </div>



</body>
</html>
{% endblock %}
